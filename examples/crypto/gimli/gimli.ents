// Gimli permutation and Gimli-Hash
// Based on the Gimli specification by Bernstein, KÃ¶lbl, Lucks, et al.
// State is 384 bits: 12 x 32-bit words arranged as a 3x4 matrix

export "mem" memory 1 

// Gimli permutation: state is permuted in place
// `state` is a pointer to 12 u32 words (48 bytes)
export "gimli"
func gimli(state:[*12]u32) {
  let round:u32 = 24

  loop {
    // Apply SP-box to each column
    for col in 4 {
      let x = state[col] <<< 24
      let y = state[col + 4] <<< 9
      let z = state[col + 8]

      // Non-linear mixing
      state[col + 8] = x ^ (z << 1) ^ ((y & z) << 2)
      state[col + 4] = y ^ x ^ ((x | z) << 1)
      state[col] = z ^ y ^ ((x & y) << 3)
    }

    // Linear layer: swap words based on round number
    match round & 3 {
      0 => {
        // Small swap: swap columns 0,1 and 2,3
        let x = state[0]
        state[0] = state[1]
        state[1] = x
        let x2 = state[2]
        state[2] = state[3]
        state[3] = x2
        // Add round constant
        state[0] ^= 0x9e377900 | round
      }
      2 => {
        // Big swap: swap columns 0,2 and 1,3
        let x = state[0]
        state[0] = state[2]
        state[2] = x
        let x2 = state[1]
        state[1] = state[3]
        state[3] = x2
      }
      _ => {}
    }

    round -= 1
    break when round == 0
  }
}

func slice_ptr_pun_test() {
  // should have type [6]u8
  let default_string = "Gimli!"
  // `default_string.ptr` has type [*]u8 (many-pointer, no known length)
  let ptr_from_default = default_string.ptr
  // Explicit [*_]u8 annotation - type error when assigned from .ptr (no known length)
  // let p:[*_]u8 = default_string.ptr  // ERROR: cannot assign [*]u8 to [*_]u8
  // should have type []u8 not [13]u8
  let slice:[]u8 = "Hello, World!"
  // should have type [*]u8
  let ptr = slice.ptr
  // should allow type punning
  let first_u32 = ptr.u32[0] // Type punning to read first 4 bytes as u32

  // A fat-pointer with redundant null termination
  let slice_zero:[!]u8 = "null termination!"
  // should have type [*!]u8
  let ptr_zero = slice_zero.ptr
  // should allow type punning
  let first_u32_zero = ptr_zero.u32[0]

  // A fat-pointer with LEB128 length prefix
  let slice_prefix:[?]u8 = "length prefix?"
  // should have type [*?]u8
  let ptr_prefix = slice_prefix.ptr
  // should allow type punning
  let first_u32_prefix = ptr_prefix.u32[0]

  let wider_slice:*[_]u16 = [0x1234, 0x5678, 0x9abc]
  // should have type [*]u16
  let wider_ptr = wider_slice.ptr
  wider_slice.wid
  wider_slice.len
  // should allow type punning
  let first_u32_wide = wider_ptr.u32[0] // Should read 0x56781234
  // What about offset pointers?  Should these preserve all type state?
  let later_ptr = wider_ptr + 2
}

// Global state for Gimli-Hash.
// This is a reserved area of linear memory to hold the state.
global hash_state:[*_]u32 = [0;12]

// Gimli-Hash: absorb input and squeeze 32-byte output
// Uses rate of 16 bytes (128 bits)
export "gimli_hash"
func gimli_hash(input:[]u8, output:*[32]u8) {
  // Initialize state to zero
  memset(hash_state.u8, 0, hash_state.len * hash_state.wid)
  let len = input.len
  let input_ptr = input.ptr

  // Absorb phase: process 16-byte blocks
  while len >= 16 {
    // XOR input into rate portion of state (first 16 bytes = 4 words)
    // Do the XOR 8 bytes at a time via type punning.
    hash_state.u64[0] ^= input_ptr.u64[0]
    hash_state.u64[1] ^= input_ptr.u64[1]

    // TODO: find out if wasm supports 128 bit xor
    hash_state.u128[0] ^= input_ptr.u128[0]
    let t = hash_state.u128[0]
    gimli(hash_state)
    input_ptr += 16
    len -= 16
  }

  // Absorb remaining bytes with padding
  for i in len {
    hash_state.u8[i] ^= input_ptr[i]
  }
  // Pad with 0x1F at position len
  hash_state.u8[len] ^= 0x1f
  // Pad with 0x80 at position 15 (end of rate)
  hash_state.u8[15] ^= 0x80

  gimli(hash_state)

  // Squeeze phase: extract 32 bytes of output (two blocks of 16 bytes)
  for i in 16 {
    output[i] = hash_state.u8[i]
  }

  gimli(hash_state)

  for i in 16 {
    output[i + 16] = hash_state.u8[i]
  }
}
