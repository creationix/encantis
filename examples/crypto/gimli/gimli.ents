// Gimli permutation and Gimli-Hash
// Based on the Gimli specification by Bernstein, KÃ¶lbl, Lucks, et al.
// State is 384 bits: 12 x 32-bit words arranged as a 3x4 matrix

export "mem" memory 1

// Gimli permutation: state is permuted in place
// `state` is a pointer to 12 u32 words (48 bytes)
export "gimli"
func gimli(state:*[12;u32]) {
  let round:u32 = 24

  loop {
    // Apply SP-box to each column
    for col in 4 {
      let x = state[col] <<< 24
      let y = state[col + 4] <<< 9
      let z = state[col + 8]

      // Non-linear mixing
      state[col + 8] = x ^ (z << 1) ^ ((y & z) << 2)
      state[col + 4] = y ^ x ^ ((x | z) << 1)
      state[col] = z ^ y ^ ((x & y) << 3)
    }

    // Linear layer: swap words based on round number
    match round & 3 {
      0 => {
        // Small swap: swap columns 0,1 and 2,3
        let x = state[0]
        state[0] = state[1]
        state[1] = x
        let x2 = state[2]
        state[2] = state[3]
        state[3] = x2
        // Add round constant
        state[0] ^= 0x9e377900 | round
      }
      2 => {
        // Big swap: swap columns 0,2 and 1,3
        let x = state[0]
        state[0] = state[2]
        state[2] = x
        let x2 = state[1]
        state[1] = state[3]
        state[3] = x2
      }
      _ => {}
    }

    round -= 1
    break when round == 0
  }
}

// Gimli-Hash: absorb input and squeeze 32-byte output
// Uses rate of 16 bytes (128 bits)
export "gimli_hash"
func gimli_hash(input:*[u8], output:*[32;u8]) {
  let state:[12;u32] = 0  // 48 bytes state, initialized to zero
  let len = input.len
  let input_ptr = input.ptr

  // Absorb phase: process 16-byte blocks
  while len >= 16 {
    // XOR input into rate portion of state (first 16 bytes = 4 words)
    for i in 16 {
      state.u8[i] ^= input_ptr[i]
    }
    gimli(state)
    input_ptr += 16
    len -= 16
  }

  // Absorb remaining bytes with padding
  for i in len {
    state.u8[i] ^= input_ptr[i]
  }
  // Pad with 0x1F at position len
  state.u8[len] ^= 0x1f
  // Pad with 0x80 at position 15 (end of rate)
  state.u8[15] ^= 0x80

  gimli(state)

  // Squeeze phase: extract 32 bytes of output (two blocks of 16 bytes)
  for i in 16 {
    output[i] = state.u8[i]
  }

  gimli(state)

  for i in 16 {
    output[i + 16] = state.u8[i]
  }
}
