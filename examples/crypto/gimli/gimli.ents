// Gimli permutation and Gimli-Hash
// Based on the Gimli specification by Bernstein, KÃ¶lbl, Lucks, et al.
// State is 384 bits: 12 x 32-bit words arranged as a 3x4 matrix

// Gimli permutation: state is permuted in place
// `state` is a pointer to 12 u32 words (48 bytes)
export func gimli(state:[*12]u32) {
  let round:u32 = 24

  loop {
    // Apply SP-box to each column
    for col in 4 {
      let x = state[col] <<< 24
      let y = state[col + 4] <<< 9
      let z = state[col + 8]

      // Non-linear mixing
      state[col + 8] = x ^ (z << 1) ^ ((y & z) << 2)
      state[col + 4] = y ^ x ^ ((x | z) << 1)
      state[col] = z ^ y ^ ((x & y) << 3)
    }

    // Linear layer: swap words based on round number
    match round & 3 {
      0 => {
        // Small swap: swap columns 0,1 and 2,3
        let x = state[0]
        state[0] = state[1]
        state[1] = x
        let x2 = state[2]
        state[2] = state[3]
        state[3] = x2
        // Add round constant
        state[0] ^= 0x9e377900 | round
      }
      2 => {
        // Big swap: swap columns 0,2 and 1,3
        let x = state[0]
        state[0] = state[2]
        state[2] = x
        let x2 = state[1]
        state[1] = state[3]
        state[3] = x2
      }
    }

    round -= 1
    break when round == 0
  }
}

// Global state for Gimli-Hash.
// This is a reserved area of linear memory to hold the state.
def hash_state = mut [0:u32;12]

// Gimli-Hash: absorb input and squeeze variable-length output (XOF)
// Uses rate of 16 bytes (128 bits)
export func gimli-hash(input:[]u8, output:[]u8) {
  // Initialize state to zero
  memset(hash_state.u8, 0, hash_state.len * hash_state.wid)
  let len = input.len
  let input_ptr = input.ptr

  // Absorb phase: process 16-byte blocks
  while len >= 16 {
    hash_state.u128[0] ^= input_ptr.u128[0]
    gimli(hash_state)
    input_ptr += 16
    len -= 16
  }

  // Absorb remaining bytes with padding
  for i in len {
    hash_state.u8[i] ^= input_ptr[i]
  }
  hash_state.u8[len] ^= 0x1f
  hash_state.u8[15] ^= 0x80

  gimli(hash_state)

  // Squeeze phase: extract requested bytes
  let out_ptr = output.ptr
  let remaining = output.len

  // Extract full 16-byte blocks
  while remaining >= 16 {
    out_ptr.u128[0] = hash_state.u128[0]
    out_ptr += 16
    remaining -= 16
    if remaining > 0 {
      gimli(hash_state)
    }
  }

  // Extract final partial block
  for i in remaining {
    out_ptr[i] = hash_state.u8[i]
  }
}
