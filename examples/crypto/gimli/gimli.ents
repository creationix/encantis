// Gimli permutation and Gimli-Hash
// Based on the Gimli specification by Bernstein, KÃ¶lbl, Lucks, et al.
// State is 384 bits: 12 x 32-bit words arranged as a 3x4 matrix

export "mem" memory 1

// Gimli permutation: state is permuted in place
// `state` is a pointer to 12 u32 words (48 bytes)
export "gimli"
func gimli(state:[*12]u32) {
  let round:u32 = 24

  loop {
    // Apply SP-box to each column
    for col in 4 {
      let x = state[col] <<< 24
      let y = state[col + 4] <<< 9
      let z = state[col + 8]

      // Non-linear mixing
      state[col + 8] = x ^ (z << 1) ^ ((y & z) << 2)
      state[col + 4] = y ^ x ^ ((x | z) << 1)
      state[col] = z ^ y ^ ((x & y) << 3)
    }

    // Linear layer: swap words based on round number
    match round & 3 {
      0 => {
        // Small swap: swap columns 0,1 and 2,3
        let x = state[0]
        state[0] = state[1]
        state[1] = x
        let x2 = state[2]
        state[2] = state[3]
        state[3] = x2
        // Add round constant
        state[0] ^= 0x9e377900 | round
      }
      2 => {
        // Big swap: swap columns 0,2 and 1,3
        let x = state[0]
        state[0] = state[2]
        state[2] = x
        let x2 = state[1]
        state[1] = state[3]
        state[3] = x2
      }
      _ => {}
    }

    round -= 1
    break when round == 0
  }
}

// Global state for Gimli-Hash.
// This is a reserved area of linear memory to hold the state.
def hash_state:[*_]u32 = mut [0;12]

// Gimli-Hash: absorb input and squeeze 32-byte output
// Uses rate of 16 bytes (128 bits)
export "gimli_hash"
func gimli_hash(input:[]u8, output:*[32]u8) {
  // Initialize state to zero
  memset(hash_state.u8, 0, hash_state.len * hash_state.wid)
  let len = input.len
  let input_ptr = input.ptr

  // Absorb phase: process 16-byte blocks
  while len >= 16 {
    // XOR input into rate portion of state (first 16 bytes = 4 words)
    // Do the XOR 8 bytes at a time via type punning.
    hash_state.u64[0] ^= input_ptr.u64[0]
    hash_state.u64[1] ^= input_ptr.u64[1]

    // TODO: find out if wasm supports 128 bit xor
    hash_state.u128[0] ^= input_ptr.u128[0]
    let t = hash_state.u128[0]
    gimli(hash_state)
    input_ptr += 16
    len -= 16
  }

  // Absorb remaining bytes with padding
  for i in len {
    hash_state.u8[i] ^= input_ptr[i]
  }
  // Pad with 0x1F at position len
  hash_state.u8[len] ^= 0x1f
  // Pad with 0x80 at position 15 (end of rate)
  hash_state.u8[15] ^= 0x80

  gimli(hash_state)

  // Squeeze phase: extract 32 bytes of output (two blocks of 16 bytes)
  for i in 16 {
    output[i] = hash_state.u8[i]
  }

  gimli(hash_state)

  for i in 16 {
    output[i + 16] = hash_state.u8[i]
  }
}
