// BLAKE2b-256 cryptographic hash function
// RFC 7693 - https://tools.ietf.org/html/rfc7693
// Implements both 256-bit and 512-bit variants
// Returns hash value directly as scalar via type punning from internal state

// BLAKE2b IV - from SHA-512 fractional parts of square roots of first 8 primes
def iv = [
  0x6a09e667f3bcc908:u64,
  0xbb67ae8584caa73b:u64,
  0x3c6ef372fe94f82b:u64,
  0xa54ff53a5f1d36f1:u64,
  0x510e527fade682d1:u64,
  0x9b05688c2b3e6c1f:u64,
  0x1f83d9abfb41bd6b:u64,
  0x5be0cd19137e2179:u64
]

// BLAKE2b-256 parameters packed into first IV word XOR
// digest_length=32, key_length=0, fanout=1, depth=1, rest=0
def param-256 = 0x0000000001010020:u64
def param-512 = 0x0000000001010040:u64

// Sigma permutation schedule (12 rounds Ã— 16 indices, from RFC 7693)
def sigma = [
  x"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f",
  x"0e 0a 04 08 09 0f 0d 06 01 0c 00 02 0b 07 05 03",
  x"0b 08 0c 00 05 02 0f 0d 0a 0e 03 06 07 01 09 04",
  x"07 09 03 01 0d 0c 0b 0e 02 06 05 0a 04 00 0f 08",
  x"09 00 05 07 02 04 0a 0f 0e 01 0b 0c 06 08 03 0d",
  x"02 0c 06 0a 00 0b 08 03 04 0d 07 05 0f 0e 01 09",
  x"0c 05 01 0f 0e 0d 04 0a 00 07 06 03 09 02 0b 08",
  x"0d 0b 07 0e 0c 01 03 09 05 00 0f 04 08 06 02 0a",
  x"06 0f 0e 09 0b 03 00 08 0c 02 0d 07 01 04 0a 05",
  x"0a 02 08 04 07 06 01 05 0f 0b 09 0e 03 0c 0d 00",
  x"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f",
  x"0e 0a 04 08 09 0f 0d 06 01 0c 00 02 0b 07 05 03"
]

// Global working state (8 x u64 = 64 bytes, first 32 bytes serve as u256 output)
def h = mut [0:u64;8]

// Global working vector for compress (16 x u64 = 128 bytes)
def cv = mut [0:u64;16]

// Global padding buffer (16 x u64 = 128 bytes)
def pad = mut [0:u64;16]

// G mixing function - the core of BLAKE2
// Mixes four state words with two message words
inline func g(v:[*16]u64, a:u32, b:u32, c:u32, d:u32, x:u64, y:u64) {
  v[a] += v[b] + x
  v[d] = (v[d] ^ v[a]) >>> 32
  v[c] += v[d]
  v[b] = (v[b] ^ v[c]) >>> 24
  v[a] += v[b] + y
  v[d] = (v[d] ^ v[a]) >>> 16
  v[c] += v[d]
  v[b] = (v[b] ^ v[c]) >>> 63
}

// Compress one 128-byte block into the state
// t_lo/t_hi = 128-bit byte counter, last = finalization flag
func compress(hs:[*8]u64, block:[*16]u64, t_lo:u64, t_hi:u64, last:u32) {
  // Initialize working vector cv[0..15] from state and IV
  cv.u512[0] = hs.u512[0]  // cv[0..7] = hs[0..7]
  cv.u512[1] = iv.u512[1]  // cv[8..15] = iv[0..7]
  cv[12] ^= t_lo    // XOR with lower 64 bits of counter
  cv[13] ^= t_hi    // XOR with upper 64 bits of counter
  if last != 0 {
    cv[14] ^= 0xffffffffffffffff:u64
  }

  // 12 rounds of mixing
  for round in 12 {
    let s = (sigma + (round * 16)) as [*16]u8

    // Column step
    g(cv, 0, 4,  8, 12, block[s[0]], block[s[1]])
    g(cv, 1, 5,  9, 13, block[s[2]], block[s[3]])
    g(cv, 2, 6, 10, 14, block[s[4]], block[s[5]])
    g(cv, 3, 7, 11, 15, block[s[6]], block[s[7]])

    // Diagonal step
    g(cv, 0, 5, 10, 15, block[s[8]],  block[s[9]])
    g(cv, 1, 6, 11, 12, block[s[10]], block[s[11]])
    g(cv, 2, 7,  8, 13, block[s[12]], block[s[13]])
    g(cv, 3, 4,  9, 14, block[s[14]], block[s[15]])
  }

  // XOR the two halves of cv into hs
  hs.u512[0] ^= cv.u512[0] ^ cv.u512[1]
}

// BLAKE2b-256: Hash arbitrary data to 256 bits
export func blake2b-256(data:[]u8) -> (hash:u256) {
  // Initialize state with IV XOR parameters
  h.u512[0] = iv.u512[0]  // h[0..7] = iv[0..7]
  h[0] ^= param-256

  let ptr = data.ptr
  let remaining = data.len
  let t_lo:u64 = 0  // Byte counter (lower 64 bits)
  let t_hi:u64 = 0  // Byte counter (upper 64 bits)

  // Process all complete 128-byte blocks (except last)
  while remaining > 128 {
    t_lo += 128
    if t_lo < 128 { t_hi += 1 }  // Handle overflow
    compress(h, ptr as [*16]u64, t_lo, t_hi, 0)
    ptr += 128
    remaining -= 128
  }

  // Final block - pad with zeros
  memset(pad.u8, 0, 128)
  memcpy(pad.u8, ptr, remaining)

  t_lo += remaining
  if t_lo < remaining { t_hi += 1 }
  compress(h, pad, t_lo, t_hi, 1)

  // Return first 256 bits directly from h via type punning
  hash = h.u256[0]
}

// BLAKE2b-512: Full 512-bit output
export func blake2b-512(data:[]u8) -> (hash:u512) {
  // Initialize state with IV XOR parameters
  h.u512[0] = iv.u512[0]  // h[0..7] = iv[0..7]
  h[0] ^= param-512

  let ptr = data.ptr
  let remaining = data.len
  let t_lo:u64 = 0
  let t_hi:u64 = 0

  while remaining > 128 {
    t_lo += 128
    if t_lo < 128 { t_hi += 1 }
    compress(h, ptr as [*16]u64, t_lo, t_hi, 0)
    ptr += 128
    remaining -= 128
  }

  // Final block - pad with zeros
  memset(pad.u8, 0, 128)
  memcpy(pad.u8, ptr, remaining)

  t_lo += remaining
  if t_lo < remaining { t_hi += 1 }
  compress(h, pad, t_lo, t_hi, 1)

  // Copy all 8 words to output
  hash = h.u512[0]
}
