Encantis {
  // ============================================================================
  // Top-Level
  // ============================================================================

  Module = Declaration*

  Declaration = ImportDecl
              | ExportDecl
              | FuncDecl
              | TypeDecl
              | EnumDecl
              | DefDecl
              | GlobalDecl
              | MemoryDecl

  // ============================================================================
  // Helpers
  // ============================================================================

  TypeAnnotation = ":" Type
  Assign = "=" Expr
  PatternWithType = Pattern TypeAnnotation?

  // ============================================================================
  // Type Declarations
  // ============================================================================

  TypeDecl = type typeIdent "=" Type

  // ============================================================================
  // Enum Declarations (Tagged Unions / ADTs)
  // ============================================================================

  EnumDecl = enum typeIdent "{" EnumVariant* "}"

  EnumVariant = typeIdent ("(" FieldList ")")? ","?

  // ============================================================================
  // Imports
  // ============================================================================

  ImportDecl = import stringLiteral "(" ImportGroupItem+ ")"  -- group
             | import stringLiteral ImportGroupItem           -- single

  ImportGroupItem = stringLiteral ImportItem

  ImportItem = func ident? FuncSignature   -- func
             | global ident TypeAnnotation -- global
             | memory intLiteral           -- memory

  // ============================================================================
  // Exports
  // ============================================================================

  ExportDecl = export stringLiteral Exportable

  Exportable = FuncDecl
             | GlobalDecl
             | MemoryDecl

  // ============================================================================
  // Functions
  // ============================================================================

  FuncDecl = inline? func ident? FuncSignature Body

  // Function signature - return type is optional (defaults to void)
  // Uses BaseType for input to avoid ambiguity with function types
  FuncSignature = BaseType ("->" Type)?

  FieldList = NonemptyListOf<Field, ",">

  Field = ident TypeAnnotation  -- named
        | Type                  -- anonymous

  Body = Block      -- block
       | "=>" Expr  -- arrow

  Block = "{" Statement* "}"

  // ============================================================================
  // Definitions
  // ============================================================================

  DefDecl = def ident Assign

  // ============================================================================
  // Globals
  // ============================================================================

  GlobalDecl = global PatternWithType Assign?

  // ============================================================================
  // Memory
  // ============================================================================

  MemoryDecl = memory intLiteral intLiteral? DataBlock?
  DataBlock = "{" DataEntry* "}"
  DataEntry = intLiteral "=>" Expr ","?     -- offset
            | ident TypeAnnotation ","?     -- alloc

  // ============================================================================
  // Types
  // ============================================================================

  // Array/pointer bracket syntax - a mini-language inside []
  // All bracket types are pointers (no by-value arrays)
  //
  // Structure: [*? length? framing*]T
  //   - Optional * at start = thin many-pointer (vs fat slice)
  //   - Optional length = _ (inferred) or N (explicit)
  //   - Zero or more framing = ! (null-term) or ? (LEB128 prefix)
  //
  // Thin many-pointers (just ptr, no runtime length):
  // - [*]T = many-pointer, unknown length
  // - [*!]T = many-pointer, null-terminated
  // - [*?]T = many-pointer, LEB128-prefixed
  // - [*5]T = many-pointer, known length 5
  // - [*_]T = many-pointer, inferred length
  // - [*5!]T = many-pointer, known length 5, null-terminated
  // - [*!!]T = many-pointer, double null-terminated (2D)
  //
  // Fat slices (ptr + runtime length):
  // - []T = slice, runtime length only
  // - [!]T = slice + null-terminated
  // - [?]T = slice + LEB128-prefixed
  // - [5]T = slice + known length 5 (redundant: runtime + comptime)
  // - [_]T = slice + inferred length
  // - [5!]T = slice + known length 5 + null-terminated
  //
  // Nesting (left bracket = outermost dimension):
  // - [][]T - slices of slices
  // - [*][5]T - many-pointer to length-5 slices
  // - [*!?]T - null-term outer, LEB128 inner (flat layout)
  //
  // Function types use -> syntax:
  // - i32 -> i32 (simple types)
  // - (i32, i32) -> i32 (tuple input)
  // - (x: i32) -> (result: i32) (named params/returns)
  // - () -> i32 (void input)
  // - i32 -> () (void output)
  // Note: -> is right-associative, so a -> b -> c means a -> (b -> c)
  Type = BaseType "->" Type   -- func
       | BaseType             -- base

  // Base types (atoms that can compose into function types)
  BaseType = "*" Type                          -- pointer
           | "[" arrayTypePrefix? "]" Type     -- array
           | "(" FieldList? ")"                -- composite
           | ComptimeType                      -- comptimeScalar
           | PrimitiveType                     -- primitive
           | BuiltinType                       -- builtin
           | typeIdent                         -- named


        // Mini-language: [*? length? framing*]
        arrayTypePrefix = "*" arrayLength? arrayFraming*   -- manyPointer
                        | arrayLength arrayFraming*        -- sliceWithLength
                        | arrayFraming+                    -- sliceWithFraming

        // Length: _ (inferred) or decimal digits
        arrayLength = "_"         -- inferred
                    | digit+      -- explicit

        // Framing: ! (null-terminator) or ? (LEB128 prefix)
        arrayFraming = "!" | "?"

  PrimitiveType = "i8" | "i16" | "i32" | "i64"
                | "u8" | "u16" | "u32" | "u64"
                | "f32" | "f64"
                | "bool"

  // Built-in types: str (unique UTF-8 string), bytes (u8 slice)
  BuiltinType = str | bytes

  ComptimeType = int "(" intLiteral ")"      -- int
               | float "(" floatLiteral ")"  -- float

  // ============================================================================
  // Statements
  // ============================================================================

  Statement = LetStmt
            | SetStmt
            | WhileStmt
            | ForStmt
            | LoopStmt
            | ReturnStmt
            | BreakStmt
            | ContinueStmt
            | AssignmentStmt
            | ExpressionStmt

  LetStmt = let PatternWithType Assign?

  SetStmt = set PatternWithType Assign

  WhileStmt = while Expr Body

  ForStmt = for ForBinding in Expr Body

  ForBinding = ident "," ident  -- withIndex
             | ident            -- valueOnly

  LoopStmt = loop Body

  ReturnStmt = return Expr? WhenClause?

  BreakStmt = break WhenClause?

  ContinueStmt = continue WhenClause?

  WhenClause = when Expr

  AssignmentStmt = LValue assignOp Expr

  assignOp = "<<<=" | ">>>=" | "<<=" | ">>="
           | "+|=" | "-|=" | "*|="
           | "+=" | "-=" | "*=" | "/=" | "%="
           | "&=" | "|=" | "^="
           | "="

  ExpressionStmt = Expr

  // ============================================================================
  // L-Values and Access Suffixes
  // ============================================================================

  LValue = ident AccessSuffix*

  AccessSuffix = "." digit+        -- tupleIndex
               | "." "*"           -- deref
               | "." PrimitiveType -- typePun
               | "." ident         -- field
               | "[" Expr "]"      -- index

  // ============================================================================
  // Patterns
  // ============================================================================

  Pattern = "(" PatternList ")"  -- tuple
          | ident                -- ident

  PatternList = NonemptyListOf<PatternElem, ",">

  PatternElem = ident ":" ident  -- namedExplicit
              | ident ":"        -- namedShort
              | Pattern          -- positional

  // ============================================================================
  // Expressions (by precedence, lowest to highest)
  // ============================================================================

  Expr = OrExpr

  // Logical OR (lowest precedence)
  OrExpr = OrExpr "||" AndExpr  -- or
         | AndExpr

  // Logical AND
  AndExpr = AndExpr "&&" NotExpr  -- and
          | NotExpr

  // Logical NOT
  NotExpr = "!" NotExpr  -- not
          | CompareExpr

  // Comparison
  CompareExpr = CompareExpr compareOp BitOrExpr  -- compare
              | BitOrExpr

  compareOp = "==" | "!=" | "<=" | ">=" | "<" | ">"

  // Bitwise OR
  BitOrExpr = BitOrExpr "|" BitXorExpr  -- or
            | BitXorExpr

  // Bitwise XOR
  BitXorExpr = BitXorExpr "^" BitAndExpr  -- xor
             | BitAndExpr

  // Bitwise AND
  BitAndExpr = BitAndExpr "&" ShiftExpr  -- and
             | ShiftExpr

  // Shift
  ShiftExpr = ShiftExpr shiftOp AddExpr  -- shift
            | AddExpr

  shiftOp = "<<<" | ">>>" | "<<" | ">>"

  // Addition/Subtraction
  AddExpr = AddExpr addOp MulExpr  -- add
          | MulExpr

  addOp = "+|" | "-|" | "+" | "-"

  // Multiplication/Division
  MulExpr = MulExpr mulOp UnaryExpr  -- mul
          | UnaryExpr

  mulOp = "*|" | "*" | "/" | "%"

  // Unary
  UnaryExpr = "-" UnaryExpr   -- neg
            | "~" UnaryExpr   -- complement
            | "&" UnaryExpr   -- ref
            | CastExpr

  // Cast and Annotation
  CastExpr = PostfixExpr as Type   -- cast
           | PostfixExpr TypeAnnotation  -- annotation
           | PostfixExpr

  // Postfix (highest precedence for operators)
  PostfixExpr = PrimaryExpr PostfixOp*
              
  PostfixOp = AccessSuffix
            | "(" ArgList? ")"  -- call

  // Primary (atoms)
  PrimaryExpr = IfExpr
              | MatchExpr
              | ArrayLiteral
              | "(" ArgList ")"      -- tupleOrStruct
              | "(" Expr ")"         -- group
              | "(" ")"              -- unit
              | typeIdent "(" ArgList? ")"  -- constructor
              | literal
              | ident

  // Array literal: [expr, expr, ...] or [expr; count]
  ArrayLiteral = "[" Expr ";" Expr "]"    -- repeat
               | "[" ListOf<Expr, ","> "]"  -- list

  // ============================================================================
  // If Expression / Branches
  // ============================================================================

  IfExpr = if let MatchPattern "=" Expr Body ElifBranch* ElseBranch?  -- ifLet
         | if Expr Body ElifBranch* ElseBranch?                       -- if

  ElifBranch = elif let MatchPattern "=" Expr Body  -- elifLet
             | elif Expr Body                       -- elif

  ElseBranch = else Body

  // ============================================================================
  // Match Expression
  // ============================================================================

  MatchExpr = match Expr "{" MatchArm* "}"

  MatchArm = MatchPatterns "=>" (Block | Expr) ","?

  MatchPatterns = NonemptyListOf<MatchPattern, ",">

  // Match patterns support:
  // - Point(0, y)    constructor with nested patterns
  // - (0, y)         tuple pattern
  // - Red            unit variant (typeIdent)
  // - x              binding (ident, lowercase)
  // - 42, "hello"    literals
  // - _              wildcard
  MatchPattern = typeIdent "(" MatchPatternList ")"  -- constructor
               | "(" MatchPatternList ")"            -- tuple
               | typeIdent                           -- variant
               | literal                             -- literal
               | ident                               -- binding
               | "_"                                 -- wildcard

  MatchPatternList = NonemptyListOf<MatchPatternElem, ",">

  MatchPatternElem = ident ":" MatchPattern  -- named
                   | ident ":"               -- namedShort
                   | MatchPattern            -- positional

  // ============================================================================
  // Arguments
  // ============================================================================

  ArgList = NonemptyListOf<Arg, ",">

  Arg = ident ":" Expr  -- named
      | ident ":"       -- shorthand
      | Expr            -- positional

  // ============================================================================
  // Literals
  // ============================================================================

  literal = numberLiteral
          | stringLiteral
          | boolLiteral

  numberLiteral = floatLiteral
                | intLiteral

  intLiteral = "-"? 
    ( hexLiteral
    | binaryLiteral
    | octalLiteral
    | dozenalLiteral
    | decimalLiteral
    )

  decimalLiteral = digit+

  hexLiteral = "0x" hexDigit+

  binaryLiteral = "0b" binaryDigit+

  octalLiteral = "0o" octalDigit+

  dozenalLiteral = "0d" dozenalDigit+

  floatLiteral = "-"? digit+ "." digit+ exponent?

  exponent = caseInsensitive<"e"> ("+" | "-")? digit+

  stringLiteral = utf8String
                | charString
                | hexString
                | base64String

  utf8String = "\"" utf8Char* "\""

  charString = "'" utf8Char* "'"

  hexString = "x\"" (hexByte | space)* "\""

  base64String = "b\"" (base64Char | space)* "\""

  utf8Char = escapeSeq
           | ~("\"" | "'" | "\\") any

  escapeSeq = "\\" "x" hexDigit hexDigit  -- hex
            | "\\" escapeChar             -- simple

  escapeChar = "n" | "t" | "r" | "\\" | "\"" | "'"

  hexByte = hexDigit hexDigit

  base64Char = letter | digit | "+" | "/" | "="

  boolLiteral = true | false

  // ============================================================================
  // Lexical Rules
  // ============================================================================

  // Identifiers
  ident = ~keyword lowerStart identChar*

  // Type identifiers: Foo (structural) or @Foo (unique/nominal)
  typeIdent = "@"? upperStart identChar*

  lowerStart = "a".."z"

  upperStart = "A".."Z"

  identChar = letter | digit | "_" | "-"

  // hexDigit is built-in, but we need these custom ones
  binaryDigit = "0" | "1"

  octalDigit = "0".."7"

  dozenalDigit = digit | "a".."b" | "A".."B"

  // Keywords
  keyword = (if | elif | else | while | for | in | loop | match
           | break | continue | return | when
           | func | let | set | global | def | type | enum
           | import | export | memory | inline
           | as | true | false | int | float
           | str | bytes) ~identChar

  if = "if" ~identChar
  elif = "elif" ~identChar
  else = "else" ~identChar
  while = "while" ~identChar
  for = "for" ~identChar
  in = "in" ~identChar
  loop = "loop" ~identChar
  match = "match" ~identChar
  break = "break" ~identChar
  continue = "continue" ~identChar
  return = "return" ~identChar
  when = "when" ~identChar
  func = "func" ~identChar
  let = "let" ~identChar
  set = "set" ~identChar
  global = "global" ~identChar
  def = "def" ~identChar
  type = "type" ~identChar
  enum = "enum" ~identChar
  import = "import" ~identChar
  export = "export" ~identChar
  memory = "memory" ~identChar
  inline = "inline" ~identChar
  as = "as" ~identChar
  true = "true" ~identChar
  false = "false" ~identChar
  int = "int" ~identChar
  float = "float" ~identChar
  str = "str" ~identChar
  bytes = "bytes" ~identChar

  // Comments
  comment = lineComment | blockComment

  lineComment = "//" (~"\n" any)*

  blockComment = "/*" (~"*/" any)* "*/"

  // Whitespace (override to include comments)
  space := " " | "\t" | "\n" | "\r" | comment
}
