Encantis {
  // ============================================================================
  // Top-Level
  // ============================================================================

  Module = Declaration*

  Declaration = ImportDecl
              | ExportDecl
              | FuncDecl
              | TypeDecl
              | DefDecl
              | GlobalDecl
              | MemoryDecl

  // ============================================================================
  // Helpers
  // ============================================================================

  TypeAnnotation = ":" Type
  Assign = "=" Expr

  // ============================================================================
  // Type Declarations
  // ============================================================================

  TypeDecl = type typeIdent "=" Type

  // ============================================================================
  // Imports
  // ============================================================================

  ImportDecl = import stringLiteral "(" ImportGroupItem+ ")"  -- group
             | import stringLiteral ImportGroupItem           -- single

  ImportGroupItem = stringLiteral ImportItem

  ImportItem = func ident? FuncSignature   -- func
             | global ident TypeAnnotation -- global
             | memory intLiteral           -- memory

  // ============================================================================
  // Exports
  // ============================================================================

  ExportDecl = export stringLiteral Exportable

  Exportable = FuncDecl
             | GlobalDecl
             | MemoryDecl

  // ============================================================================
  // Functions
  // ============================================================================

  FuncDecl = inline? func ident? FuncSignature Body

  FuncSignature = ValueSpec ReturnSpec?

  ReturnSpec = "->" ValueSpec

  ValueSpec = "(" FieldList? ")"  -- parens
            | Type                -- single

  FieldList = NonemptyListOf<Field, ",">

  Field = ident TypeAnnotation  -- named
        | Type                  -- anonymous

  Body = Block      -- block
       | "=>" Expr  -- arrow

  Block = "{" Statement* "}"

  // ============================================================================
  // Definitions
  // ============================================================================

  DefDecl = def ident Assign

  // ============================================================================
  // Globals
  // ============================================================================

  GlobalDecl = global ident TypeAnnotation? Assign?

  // ============================================================================
  // Memory
  // ============================================================================

  MemoryDecl = memory intLiteral intLiteral? DataBlock?
  DataBlock = "{" DataEntry* "}"
  DataEntry = intLiteral "=>" Expr ","?

  // ============================================================================
  // Types
  // ============================================================================

  // Zig-inspired array/pointer syntax
  // - *T = normal pointer
  // - [*]T = many-pointer (comptime unknown length)
  // - [*:0]T = many-pointer to null-terminated array of T (i.e. ->"hello\x00")
  // - [*:?]T = many-pointer to LEB128-prefixed array of T (i.e. ->"\x05hello")
  // You can combine these for multi-dimensional arrays:
  // These are still a single pointer, but the data is laid out in a specific way.
  // The left modifier is the outermost dimension.
  // - [*:0:0]T = 2d many-pointer, null-terminated at both levels (i.e. ->"one\x00two\x00\x00")
  // - [*:?:?]T = 2d many-pointer, LEB128-prefixed at both levels (i.e. ->"\x02\x03one\x03two")
  // - [*:0:?]T - 2d many-pointer, null-terminated at outer level (i.e. ->"\x03one\x03two\x00")
  // - [*:?:0]T - 2d many-pointer, null-terminated at inner level (i.e. ->"\x02one\x00two\x00")
  // Fat Pointers (aka Slices)
  // - []T = fat-pointer (pointer + length) (aka slice)
  // - [:0]T = slices can have modifiers as well
  // Fixed Length Arrays (by-value semantics)
  // - [N]T = fixed length array of T
  // - [_]T = fixed length array with inferred length
  // - [N:0]T = fixed length arrays can have modifiers as well
  // You can nest these, the left bracket is the outermost dimension:
  // - [][]T - slices of slices
  // - [N][]T - fixed length array of slices of T
  // - [][N]T - slice of fixed length arrays of T
  // - [*][N]T - many-pointer to fixed length arrays of T
  // - [N][*][]T - fixed length array of many-pointers to slices of T
  Type = "*" Type                          -- pointer
       | "[" arrayTypePrefix? "]" Type    -- array
       | "(" FieldList? ")"                        -- composite
       | ComptimeType                              -- comptimeScalar
       | PrimitiveType                             -- primitive
       | BuiltinType                               -- builtin
       | typeIdent                                 -- named


        arrayTypePrefix = "*" arraySentinelList?  -- manyPointer
                                                                 | intLiteral arraySentinelList?  -- fixed
                                                                 | arraySentinelList              -- sliceSentinel

        arraySentinelList = ":" arraySentinel (":" arraySentinel)*

        // Array sentinels: 0 = null terminator, ? = LEB128 prefix
        arraySentinel = "0" | "?"

  PrimitiveType = "i8" | "i16" | "i32" | "i64"
                | "u8" | "u16" | "u32" | "u64"
                | "f32" | "f64"
                | "bool"

  // Built-in types: str (unique UTF-8 string), bytes (u8 slice)
  BuiltinType = str | bytes

  ComptimeType = int "(" intLiteral ")"      -- int
               | float "(" floatLiteral ")"  -- float

  // ============================================================================
  // Statements
  // ============================================================================

  Statement = LetStmt
            | SetStmt
            | WhileStmt
            | ForStmt
            | LoopStmt
            | ReturnStmt
            | BreakStmt
            | ContinueStmt
            | AssignmentStmt
            | ExpressionStmt

  LetStmt = let Pattern TypeAnnotation? Assign?

  SetStmt = set Pattern TypeAnnotation? Assign

  WhileStmt = while Expr Body

  ForStmt = for ForBinding in Expr Body

  ForBinding = ident "," ident  -- withIndex
             | ident            -- valueOnly

  LoopStmt = loop Body

  ReturnStmt = return Expr? WhenClause?

  BreakStmt = break WhenClause?

  ContinueStmt = continue WhenClause?

  WhenClause = when Expr

  AssignmentStmt = LValue assignOp Expr

  assignOp = "<<<=" | ">>>=" | "<<=" | ">>="
           | "+|=" | "-|=" | "*|="
           | "+=" | "-=" | "*=" | "/=" | "%="
           | "&=" | "|=" | "^="
           | "="

  ExpressionStmt = Expr

  // ============================================================================
  // L-Values and Access Suffixes
  // ============================================================================

  LValue = ident AccessSuffix*

  AccessSuffix = "." digit+        -- tupleIndex
               | "." "*"           -- deref
               | "." PrimitiveType -- typePun
               | "." ident         -- field
               | "[" Expr "]"      -- index

  // ============================================================================
  // Patterns
  // ============================================================================

  Pattern = "(" PatternList ")"  -- tuple
          | ident                -- ident

  PatternList = NonemptyListOf<PatternElem, ",">

  PatternElem = ident ":" ident  -- namedExplicit
              | ident ":"        -- namedShort
              | Pattern          -- positional

  // ============================================================================
  // Expressions (by precedence, lowest to highest)
  // ============================================================================

  Expr = OrExpr

  // Logical OR (lowest precedence)
  OrExpr = OrExpr "||" AndExpr  -- or
         | AndExpr

  // Logical AND
  AndExpr = AndExpr "&&" NotExpr  -- and
          | NotExpr

  // Logical NOT
  NotExpr = "!" NotExpr  -- not
          | CompareExpr

  // Comparison
  CompareExpr = CompareExpr compareOp BitOrExpr  -- compare
              | BitOrExpr

  compareOp = "==" | "!=" | "<=" | ">=" | "<" | ">"

  // Bitwise OR
  BitOrExpr = BitOrExpr "|" BitXorExpr  -- or
            | BitXorExpr

  // Bitwise XOR
  BitXorExpr = BitXorExpr "^" BitAndExpr  -- xor
             | BitAndExpr

  // Bitwise AND
  BitAndExpr = BitAndExpr "&" ShiftExpr  -- and
             | ShiftExpr

  // Shift
  ShiftExpr = ShiftExpr shiftOp AddExpr  -- shift
            | AddExpr

  shiftOp = "<<<" | ">>>" | "<<" | ">>"

  // Addition/Subtraction
  AddExpr = AddExpr addOp MulExpr  -- add
          | MulExpr

  addOp = "+|" | "-|" | "+" | "-"

  // Multiplication/Division
  MulExpr = MulExpr mulOp UnaryExpr  -- mul
          | UnaryExpr

  mulOp = "*|" | "*" | "/" | "%"

  // Unary
  UnaryExpr = "-" UnaryExpr   -- neg
            | "~" UnaryExpr   -- complement
            | "&" UnaryExpr   -- ref
            | CastExpr

  // Cast and Annotation
  CastExpr = PostfixExpr as Type   -- cast
           | PostfixExpr TypeAnnotation  -- annotation
           | PostfixExpr

  // Postfix (highest precedence for operators)
  PostfixExpr = PrimaryExpr PostfixOp*
              
  PostfixOp = AccessSuffix
            | "(" ArgList? ")"  -- call

  // Primary (atoms)
  PrimaryExpr = IfExpr
              | MatchExpr
              | ArrayLiteral
              | "(" ArgList ")"      -- tupleOrStruct
              | "(" Expr ")"         -- group
              | "(" ")"              -- unit
              | typeIdent "(" ArgList? ")"  -- constructor
              | literal
              | ident

  // Array literal: [expr, expr, ...]
  ArrayLiteral = "[" ListOf<Expr, ","> "]"

  // ============================================================================
  // If Expression / Branches
  // ============================================================================

  IfExpr = if Expr Body ElifBranch* ElseBranch?

  ElifBranch = elif Expr Body

  ElseBranch = else Body

  // ============================================================================
  // Match Expression
  // ============================================================================

  MatchExpr = match Expr "{" MatchArm* "}"

  MatchArm = MatchPatterns "=>" (Block | Expr)

  MatchPatterns = NonemptyListOf<MatchPattern, ",">

  MatchPattern = literal  -- literal
               | "_"      -- wildcard

  // ============================================================================
  // Arguments
  // ============================================================================

  ArgList = NonemptyListOf<Arg, ",">

  Arg = ident ":" Expr  -- named
      | ident ":"       -- shorthand
      | Expr            -- positional

  // ============================================================================
  // Literals
  // ============================================================================

  literal = numberLiteral
          | stringLiteral
          | boolLiteral

  numberLiteral = floatLiteral
                | intLiteral

  intLiteral = "-"? 
    ( hexLiteral
    | binaryLiteral
    | octalLiteral
    | dozenalLiteral
    | decimalLiteral
    )

  decimalLiteral = digit+

  hexLiteral = "0x" hexDigit+

  binaryLiteral = "0b" binaryDigit+

  octalLiteral = "0o" octalDigit+

  dozenalLiteral = "0d" dozenalDigit+

  floatLiteral = "-"? digit+ "." digit+ exponent?

  exponent = caseInsensitive<"e"> ("+" | "-")? digit+

  stringLiteral = utf8String
                | charString
                | hexString
                | base64String

  utf8String = "\"" utf8Char* "\""

  charString = "'" utf8Char* "'"

  hexString = "x\"" (hexByte | space)* "\""

  base64String = "b\"" (base64Char | space)* "\""

  utf8Char = escapeSeq
           | ~("\"" | "'" | "\\") any

  escapeSeq = "\\" "x" hexDigit hexDigit  -- hex
            | "\\" escapeChar             -- simple

  escapeChar = "n" | "t" | "r" | "\\" | "\"" | "'"

  hexByte = hexDigit hexDigit

  base64Char = letter | digit | "+" | "/" | "="

  boolLiteral = true | false

  // ============================================================================
  // Lexical Rules
  // ============================================================================

  // Identifiers
  ident = ~keyword lowerStart identChar*

  // Type identifiers: Foo (structural) or @Foo (unique/nominal)
  typeIdent = "@"? upperStart identChar*

  lowerStart = "a".."z"

  upperStart = "A".."Z"

  identChar = letter | digit | "_" | "-"

  // hexDigit is built-in, but we need these custom ones
  binaryDigit = "0" | "1"

  octalDigit = "0".."7"

  dozenalDigit = digit | "a".."b" | "A".."B"

  // Keywords
  keyword = (if | elif | else | while | for | in | loop | match
           | break | continue | return | when
           | func | let | set | global | def | type
           | import | export | memory | inline
           | as | true | false | int | float
           | str | bytes) ~identChar

  if = "if" ~identChar
  elif = "elif" ~identChar
  else = "else" ~identChar
  while = "while" ~identChar
  for = "for" ~identChar
  in = "in" ~identChar
  loop = "loop" ~identChar
  match = "match" ~identChar
  break = "break" ~identChar
  continue = "continue" ~identChar
  return = "return" ~identChar
  when = "when" ~identChar
  func = "func" ~identChar
  let = "let" ~identChar
  set = "set" ~identChar
  global = "global" ~identChar
  def = "def" ~identChar
  type = "type" ~identChar
  import = "import" ~identChar
  export = "export" ~identChar
  memory = "memory" ~identChar
  inline = "inline" ~identChar
  as = "as" ~identChar
  true = "true" ~identChar
  false = "false" ~identChar
  int = "int" ~identChar
  float = "float" ~identChar
  str = "str" ~identChar
  bytes = "bytes" ~identChar

  // Comments
  comment = lineComment | blockComment

  lineComment = "//" (~"\n" any)*

  blockComment = "/*" (~"*/" any)* "*/"

  // Whitespace (override to include comments)
  space := " " | "\t" | "\n" | "\r" | comment
}
